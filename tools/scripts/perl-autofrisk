#! /usr/bin/perl

#
# perl-autofrisk
#
# (C) 2007, 2008 Francesco Salvestrini <salvestrini@users.sourceforge.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

use strict;
use warnings;
use File::Find;
use File::Spec;
use File::stat;
use Cwd;

my $program = "perl-autofrisk";

my $debug_enabled = 0;

sub debug($)
{
    if ($debug_enabled) {
	my $message = shift;

	print STDERR "$program: $message";
    }
}

sub warning($)
{
    my $message = shift;

    print STDERR "$program: $message";
}

sub error($)
{
    my $message = shift;

    print STDERR "$program: $message";
}

sub bug($)
{
    my $message = shift;

    print STDERR "Bug hit: $message";    
    exit(1);
}

my @regexps = ();
my @files   = ();
my $base    = "";

sub file_filter($)
{
    my $abs_name;
    my $rel_name;

    $abs_name = $File::Find::name;
    $rel_name = File::Spec->abs2rel($abs_name, $base);

    debug("name = \`" . $rel_name . "'\n");

    if (-d $abs_name) {
	debug("Skipping \`" . $rel_name . "', it is a directory ... \n");
	return;
    }
    if (-l $abs_name) {
	warning("File \`" . $rel_name . "' is a link ... \n");
	return;
    }
    if (! -f $abs_name) {
	debug("Skipping \`" . $rel_name . "', it is not a file ... \n");
	return;
    }

    # It is a file

    if (! -r $abs_name) {
	warning("File \`" . $rel_name . "' is not readable\n");
	return;
    }

    # The file is readable

    for my $regexp (@regexps) {
	debug("Checking \`" . $regexp . "' against \`" . $rel_name . "'\n");
	my $s;
	my $t;

	$s = $regexp;
	$s =~ s/\//,/g;

	$t = $rel_name;
	$t =~ s/\//,/g;

	if ($t =~ /^$s$/) {
	    debug("Keeping, it matches regexp \`" . $regexp . "'\n");
	    push(@files, $abs_name);
	    return;
	}
    }

    debug("Dropped, it doesn't matches regexps\n");
    return;
}

#
# Main
#
if ($#ARGV < 0) {
    error("Missing parameters\n");
    exit 1;
}
if ($#ARGV > 1) {
    error("too many parameters\n");
    exit 1;
}

#
# Handle rules file
#
my $rules_file;
$rules_file = $ARGV[0];

my $rules_handle;
if (!open($rules_handle, "<", $rules_file)) {
    error("Cannot open \`" . $rules_file . "' for input\n");
    exit 1;
}

my $line_number = 0;
while (<$rules_handle>) {
    my $line;
    
    $line = $_;
    if ($line =~ /^[ \t]*#.*$/) {
	# Skip comments
    } elsif ($line =~ /^[ \t]*$/) {
	# Skip empty lines
    } elsif ($line =~ /^[ \t]*files-glob[ \t]+(.*)/) {
	my $regexp;

	$regexp = $1;
	push(@regexps, $regexp);
	debug("$regexp\n");
    } elsif ($line =~ /^[ \t]*non-critical-external[ \t](.*)/) {
	#push(@regexps, $1);
    } elsif ($line =~ /^[ \t]*non-critical-internal[ \t](.*)/) {
	#push(@regexps, $1);
    } else {
	error("Unknown line \`" . $line . "' " .
	      "found in file " . $rules_file . ":" . $line_number . "\n");
	exit 1;
    }

    $line_number++;
}

close($rules_handle);

debug("Regexps:\n");
for my $regexp (@regexps) {
    debug("regexp = \`" . $regexp . "'\n");
}

#
# Compute file list
#
$base = cwd();
debug("base = \`" . $base . "'\n");
find(\&file_filter, cwd());

debug("Files that match:\n");
for my $filename (@files) {
    debug("match = $filename\n");
}

#
# Scan each file for modules
#
my %modules;
%modules   = ();

for my $filename (@files) {
    my $filehandle;

    if (!open($filehandle, "<", $filename)) {
	error("Unable to open \`$filename' for reading ($!)\n");
	exit 1;
    }

    while (<$filehandle>) {
	if ($_ =~ /^use[ \t]*(.*);$/) {
	    $modules{$1} = "INCLUDE";
	}
    }
    
    close($filehandle);
}

#
# Remove non-critical-internal and non-critical-external modules
#

#
# Write output file
#
my $output_file;
my $output_handle;

$output_file = $rules_file . ".m4";
if (!open($output_handle, ">", $output_file)) {
    error("$program: Cannot open \`" . $output_file . "' file for output\n");
    exit 1;
}

print $output_handle "#\n";
print $output_handle "# Autogenerated file, DO NOT EDIT\n";
print $output_handle "#\n";
print $output_handle "\n";

print $output_handle "#\n";
print $output_handle "# Files matching regexps:\n";
print $output_handle "#\n";

for my $filename (@files) {
    print $output_handle "#  $filename\n";
}
print $output_handle "#\n";
print $output_handle "\n";

print $output_handle "AC_DEFUN([PERL_AUTOFRISK_CHECKS],[\n";
for my $key (keys(%modules)) {
    if ($modules{$key} =~ /^INCLUDE$/) {
	print $output_handle "AX_PROG_PERL_MODULES([$key])\n";
    } elsif ($modules{$key} =~ /^EXCLUDE$/) {
	print $output_handle "# AX_PROG_PERL_MODULES([$key])\n";
    } else {
	bug("Unknown module type");
    }
}
print $output_handle "])\n";
print $output_handle "\n";
print $output_handle "AC_DEFUN([PERL_AUTOFRISK_SUMMARY],[\n";
print $output_handle "])\n";

close($output_handle);

exit 0;
