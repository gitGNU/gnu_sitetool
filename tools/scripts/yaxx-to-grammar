#!/usr/bin/perl

#
# yaxx-to-grammar
#
# Copyright (C) 2007, 2008 Francesco Salvestrini
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

use strict;
use warnings;
use diagnostics;

use Text::Balanced;

# Slurp the whole input file
open my $fh, $ARGV[0] or die $!;
local $/;
my $input = <$fh>;
close $fh;

# Grab the three parts
$input =~ m/^(.*)%%(.*)%%(.*)$/s;
my $header = $1 or die("Wrong input file format, missing header");
my $body   = $2 or die("Wrong input file format, missing body");
my $footer = $3 or die("Wrong input file format, missing footer");

# Handle the header, extract the start symbol
my $start;

$header =~ m/[\s\t\n]*%start[\s\t\n]+(.*)[\s\t\n]+/s;
$start = $1;
$start =~ s/[\s\t\n]*//g;

$start or die("Missing start symbol in header");

# Handle the body, remove all semantic actions
my $temp      = "";
my $completed = 0;
while (!$completed) {
    my $position = index($body, "{");
    if ($position == -1) {
	$temp      .= $body;
	$completed  = 1;
	last;
    }

    my $head      = substr($body, 0, $position - 1);
    my $remainder = substr($body, $position);
    my $tail;

    ($body, $tail) = Text::Balanced::extract_bracketed($remainder, '{}');

    $tail ne $remainder or die("bug hit");

    $temp .= $head;
    $body  =  $tail;

    if ($body eq "") {
	$completed = 1;
    }
}
$body = $temp;

# Handle the footer, discard it ...

# Rearrange output again, place each rule on a single line
my $rules;
while ($body =~ s/^(.*?)\:(.*?)\;//s) {
    my $symbol     = $1;
    my $expression = $2;

    $symbol     =~ s/[\s\t\n]+/ /g;
    $symbol     =~ s/^[\s\n\t]*//;
    $symbol     =~ s/[\s\n\t]*$//;

    $expression =~ s/[\s\t\n]+/ /g;
    $expression =~ s/^[\s\n\t]*//;
    $expression =~ s/[\s\n\t]*$//;

    $rules .= $symbol . ":" . $expression . ";\n";
}

print "Start symbol '$start'\n";
print "\n";
print $rules;

exit 0;
