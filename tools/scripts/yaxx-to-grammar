#!/usr/bin/perl

#
# yaxx-to-grammar
#
# Copyright (C) 2007, 2008 Francesco Salvestrini
#                          Alessandro Massignan
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

use strict;
use warnings;
use diagnostics;

use Getopt::Long;
use Text::Balanced;

(my $ME = $0) =~ s|.*/||;
my $VERSION = "0.0.1";

sub usage ($)
{
    my $message   = shift;
    my $exit_code = ($message eq "" ? 0 : 1);
    my $STREAM    = ($exit_code == 0 ? *STDOUT : *STDERR);

    if ($exit_code != 0) {
	print $STREAM "Try `$ME --help' for more information.\n";
    } else {
	print $STREAM <<EOF;
Usage: $ME [OPTIONS] FILE

Extract grammar from a yacc/bison/yapp parser description

OPTIONS:

    --help       display this help and exit
    --version    output version information and exit

Report bugs to <salvestrini\@gmail.com>
EOF
    }

    exit $exit_code;
}

sub fatal ($)
{
    my $string = shift;
    print "$ME: $string\n";
    exit(1);
}

{
    GetOptions(
	help    => sub {
	    usage("");
	},
	version => sub {
	    print <<EOF;
$ME ($VERSION)

Copyright (C) 2007, 2008 Francesco Salvestrini
			 Alessandro Massignan

This is free software.  You may redistribute copies of it under the terms of
the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.
There is NO WARRANTY, to the extent permitted by law.
EOF
exit(0);
	},
	) or usage("Unrecognized option");

    # Slurp the whole input file
    defined($ARGV[0])     or usage("Missing input file!");
    open my $fh, $ARGV[0] or fatal($!);

    local $/;

    my $input = <$fh>;
    close $fh;

    $input =~ s/^\s*//;
    $input =~ s/\s*$//;

    # Declarations and grammar sections are required, but programs
    # section's not
    my $declarations;
    my $grammar;

    if (!(($input =~ m/^(.*)\s%%\s(.*)\s%%\s.*$/s) ||
	  ($input =~ m/^(.*)\s%%\s(.*)/s))) {
	fatal("Wrong input file format");
    }
    $declarations = $1;
    $grammar      = $2;

    # Handle declarations, extract the start symbol
    my $start;
    my $output;

    $declarations =~ /\s*\%start\s+(.*)\s*\n/;

    defined($1) or fatal("Missing start symbol in declarations");

    $start = $1;

    # Begin parsing and cleaning
    while ($grammar =~ s/^([^\'\{\#\;]+)([\'\{\#\;])//) {
	my $string;
	my $char;

	if (defined($2)) {
	    $char = $2;
	}

	# Clean up string and append it to output
	$string =  $1;
	$string =~ s/^\s*//;
	$string =~ s/\s*$//;
	$string =~ s/\s+/\ /g;

	if (defined($output)) {

	    if ($output =~ /\n$/) {
		$output = $output . $string;
	    } else {
		$output = $output . " " . $string;
	    }
	} else {
	    $output = $string;
	}

	if (!defined($char)) {
	    last;
	}

	if ($char eq '\'') {
	    # Preserve single-quoted string

	    my $extracted;
	    my $remainder;

	    ($extracted, $remainder) =
		Text::Balanced::extract_quotelike('\'' . $grammar);

	    $output  = $output . " " . $extracted;
	    $grammar = $remainder;
	} elsif ($char eq '{') {
	    # Wipe out semantic action

	    my $extracted;
	    my $remainder;

	    ($extracted, $remainder) =
		Text::Balanced::extract_bracketed('{' . $grammar, '{}');

	    $grammar = $remainder;
	} elsif ($char eq '#') {
	    # Remove comments

	    $grammar =~ s/^[^\n]*//;
	} elsif ($char eq ';') {
	    # Handling rule's end

	    $output =~ s/\s*$/\ ;\n/;
	} else {
	    fatal("Bug hit!");
	}
    }
    $output = "Start symbol " . $start . "\n\n" . $output;

    # Print output
    print $output;

    exit 0;
}
