#
# Filterchain.pm
#
# Copyright (C) 2007, 2008 Francesco Salvestrini
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

package Sitetool::Filterchain;

use 5.8.0;

use warnings;
use strict;
use diagnostics;

use Sitetool::Autoconfig;
use Sitetool::Base::Debug;
use Sitetool::Base::Trace;
use Sitetool::OS::File;
use Sitetool::OS::Shell;

BEGIN {
    use Exporter ();
    our ($VERSION, @ISA, @EXPORT);

    @ISA    = qw(Exporter);
    @EXPORT = qw(&filterchain_apply);
}

sub filterchain_apply ($$$$)
{
    my $source      = shift;
    my $destination = shift;
    my $temp_dir    = shift;
    my $filters_ref = shift;

    assert(defined($source));
    assert(defined($destination));
    assert(defined($temp_dir));
    assert(defined($filters_ref));

    my @filters = $$filters_ref;
    if ($#filters + 1 <= 0) {
	error("No defined filters into filter-chain");
	return 0;
    }

    debug("Building "                .
	  "\`" . $destination . "' " .
	  "with "                    .
	  "\`" . $source      . "'");

    my $name = undef;
    {
	debug("Mangling content name \`" . $source . "'");

	# Split path in order to get the file name
	my $volume;
	my $directories;
	my $file;

	($volume, $directories, $file) = File::Spec->splitpath($source);

	# Now remove the extension
	$name = $file;
	$name =~ s/\..*$//;
    }
    assert(defined($name));
    debug("Base content name is \`" . $name . "'");

    my $input;
    my $output;
    my $filter_ref;
    my %filter;

    $filter_ref = $filters[0];
    %filter     = %{ $filter_ref->[0] };

    # Link (hard or symbolic) the first file into temp directory
    $input  = $source;
    $output = File::Spec->catfile($temp_dir, $name . "." .$filter{SOURCE});
    if (!file_remove(File::Spec->rel2abs($output))) {
	return 0;
    }
    if (!file_link(File::Spec->rel2abs($input),
		   File::Spec->rel2abs($output))) {
	return 0;
    }

    my $i;
    $i = 0;
    while (defined($filter_ref->[$i])) {
	%filter = %{ $filter_ref->[$i] };

	$input  = File::Spec->catfile($temp_dir,
				      $name . "." . $filter{SOURCE});
	assert(defined($input));
	assert(file_ispresent($input));

	$output = File::Spec->catfile($temp_dir,
				      $name . "." . $filter{DESTINATION});
	assert(defined($output));

#	verbose("Filter $i: " . $filter{SOURCE}      . " ($input)" .
#		" -> "        . $filter{DESTINATION} . " ($output)");
	verbose("Filter $i: " . $filter{SOURCE}     .
		" -> "        . $filter{DESTINATION});

	debug("Filter infos:");
	debug("  Source:      \`" . $filter{SOURCE}      . "'");
	debug("  Destination: \`" . $filter{DESTINATION} . "'");
	debug("  Parameters:  \`" . $filter{PARAMETERS}  . "'");

	if ($filter{SOURCE} eq $filter{DESTINATION}) {
	    debug("Skipping silly operation");
	} else {
	    my $binary;
	    my $parameters;

	    $binary = File::Spec->catfile($bin_dir,
					  "filters",
					  $filter{SOURCE}     .
					  "-"                 .
					  $filter{DESTINATION});

	    $parameters = $filter{PARAMETERS};
	    assert(defined($parameters));

	    # Build environment for filter execution
	    my $perl_env   = "";
	    my $scheme_env = "";
	    my $python_env = "";
	    my $shell_env  = "";
	    my $ruby_env   = "";
	    {
		my $base;

		$base = defined($ENV{'SITETOOL_LIBRARY_PATH'}) ?
		    File::Spec->catfile($ENV{'SITETOOL_LIBRARY_PATH'}) :
		    $libs_dir;

		$perl_env   = join('@PATH_SEPARATOR@',
				   map(File::Spec->catfile($_, "perl"),
				       (split '@PATH_SEPARATOR@', $base)));

		$scheme_env = join('@PATH_SEPARATOR@',
				   map(File::Spec->catfile($_, "scheme"),
				       (split '@PATH_SEPARATOR@', $base)));

		$python_env = join('@PATH_SEPARATOR@',
				   map(File::Spec->catfile($_, "python"),
				       (split '@PATH_SEPARATOR@', $base)));

		$shell_env  = join('@PATH_SEPARATOR@',
				   map(File::Spec->catfile($_, "shell"),
				       (split '@PATH_SEPARATOR@', $base)));

		$ruby_env   = join('@PATH_SEPARATOR@',
				   map(File::Spec->catfile($_, "ruby"),
				       (split '@PATH_SEPARATOR@', $base)));

		debug("Base is:       \`" . $base       . "'");
		debug("Perl ENV is:   \`" . $perl_env   . "'");
		debug("Scheme ENV is: \`" . $scheme_env . "'");
		debug("Python ENV is: \`" . $python_env . "'");
		debug("Shell ENV is:  \`" . $shell_env  . "'");
		debug("Ruby ENV is:   \`" . $ruby_env   . "'");
	    }

	    my $chain;
	    $chain =
		"perllibdir=$perl_env "             .
		"schemelibdir=$scheme_env "         .
		"pythonlibdir=$python_env "         .
		"shelllibdir=$shell_env "           .
		"rubylibdir=$ruby_env "             .
		"$binary $input $output $parameters";

	    if (!shell_execute($chain)) {
		file_remove($destination);
		return 0;
	    }
	}

	$i++;
    }

    # Finally move the latest created file into the destination
    if (!file_move($output, $destination)) {
	file_remove($destination);
	return 0;
    }

    return 1;
}

1;
